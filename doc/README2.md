# 第二部分练习

7. 所有权转移与复制演示

目标：

理解所有权的转移（move）与浅拷贝（copy）的区别。

要求：

编写一个程序，分别使用原始类型（如整数、布尔值等，满足 Copy）和堆数据（如 String）演示赋值后发生的所有权移动。

打印变量，观察哪些类型允许被复制而无需调用 clone()，哪些类型转移后原变量不可再用。

提示：

对于满足 Copy 的类型，直接赋值会创建副本。

对于不满足 Copy 的类型（如 String），赋值操作会导致所有权的转移（或显式调用 clone() 实现深拷贝）。

8. 借用与可变引用

目标：

掌握不可变引用与可变引用的规则。

要求：

编写一个程序演示以下情况：

同一作用域内可以有多个不可变引用。

同一作用域内只能有一个可变引用，且不能与不可变引用同时存在。

利用编译器报错（注释掉错误部分）说明 Rust 如何保障内存安全。

9. 生命周期注解
目标：

理解生命周期注解在函数签名中的作用，确保返回引用的安全性。

要求：

编写一个函数 longest<'a>(s1: &'a str, s2: &'a str) -> &'a str，该函数返回两个字符串切片中较长的一个。

在 main 中调用该函数，并验证编译器能够正确推导引用的生命周期。

10. 泛型与特征约束
目标：

学习如何编写使用泛型的函数，并通过 trait 约束保证泛型参数的行为。

要求：

实现一个泛型函数 min_max<T>(slice: &[T]) -> Option<(T, T)>，返回切片中的最小值和最大值。

要求泛型参数 T 实现 PartialOrd 和 Copy 特征。

如果切片为空，返回 None。

11. 实现自定义 Trait
目标：

学习如何定义一个 trait 并为结构体实现该 trait 的方法。

要求：

定义一个 Summary trait，包含一个方法 fn summarize(&self) -> String。

创建一个结构体（例如 BlogPost），包含标题、作者、内容等字段，并为其实现 Summary trait。

在 main 中实例化该结构体并调用 summarize() 方法。

12. 错误处理与 Result 类型
目标：

掌握如何处理可能失败的操作，使用 Result 来进行错误传递。

要求：

编写一个函数 parse_number(s: &str) -> Result<i32, std::num::ParseIntError>，尝试将字符串转换成整数。

在 main 中调用该函数，对返回的 Result 使用 match 进行模式匹配，并在出错时输出错误信息。

13. 集合与迭代器
目标：

熟悉 Vec 集合的基本操作以及迭代器（iterator）的使用。

要求：

创建一个 Vec<i32> 并填充一些整数。

使用迭代器方法（如 filter、map、fold 等）完成以下功能：

过滤出偶数

计算每个元素的平方和

计算所有偶数的和，并打印结果

14. 模式匹配与 Option 类型
目标：

深入掌握 Option<T> 类型的使用和 Rust 模式匹配。

要求：

编写一个函数 describe_option(opt: Option<i32>)，使用 match 根据输入：

如果是 Some(num)，打印 "有值: num"。

如果是 None，打印 "没有值"。

15. 枚举与简单运算
目标：

学会定义枚举类型并结合模式匹配进行简单运算。

要求：

定义一个枚举 Operation，包含 Add、Subtract、Multiply 和 Divide 四个变体。

编写一个函数 calculate(op: Operation, a: f64, b: f64) -> Result<f64, String>：

根据枚举运算符，对 a 和 b 进行相应操作。

若遇到除零情况返回错误信息。

16. 简单文件 IO

目标：

理解如何进行基本的文件读操作，并掌握错误处理。

要求：

编写一个程序，要求从命令行接收文件路径参数。

使用 std::fs::File 和 std::io::BufReader 读取文件内容，逐行打印到控制台。

处理可能出现的 IO 错误，并给出合适的提示。
