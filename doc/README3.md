# 第三部分练习 - 多线程

1. 第1题：创建线程

使用 std::thread::spawn 创建两个线程，分别输出 "Hello from thread 1" 和 "Hello from thread 2"，并确保主线程等待它们执行完成。

2. 第2题：线程传值

将一个 String 变量的所有权传递到新线程，说明会出现什么问题并如何解决。

3. 第3题：线程共享可变状态

创建多个线程，每个线程对同一个 i32 计数器加一。要求使用 Arc<Mutex<>> 来安全共享和修改计数器，并最终在主线程中打印总数。

4. 第4题：使用 mpsc 通道

使用 Rust 的 std::sync::mpsc 创建一个通道，让多个线程向主线程发送 "Message X" 字符串，其中 X 是线程编号，主线程依次接收并打印这些消息。

5. 第5题：使用 move 闭包

解释为什么在线程中经常需要在闭包前加 move？请写一段代码说明什么情况下需要使用 move。

6. 第6题：使用 Arc<Mutex<Vec<_>>>

实现一个程序，多个线程往同一个 Vec<String> 中添加数据，最终主线程打印整个 Vec 内容。

7. 第7题：线程等待和 join 的重要性

写一段代码说明如果不调用 join()，会发生什么现象？请解释为什么 join 是必要的。

8. 第8题：一次性初始化（std::sync::Once）

使用 std::sync::Once 编写一个代码，确保多个线程中，初始化代码只执行一次（比如打印 “Init”）。

9. 第9题：线程死锁

模拟一个简单的死锁场景，例如两个线程持有不同的锁，但互相等待对方释放锁。写代码展示问题，并解释如何避免。

10. 第10题：限制线程并发数（使用信号量）

假设有 10 个任务，但希望最多只允许 3 个线程同时执行
